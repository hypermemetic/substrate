# MCP to Arbor: Complete Request Flow Architecture

This document traces a request from MCP entry through Plexus dispatch to Arbor method execution and tree rendering response.

## Overview Diagram

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                    CLIENT                                            │
│                          (Claude Code, CLI, Web UI)                                  │
└─────────────────────────────────────────┬───────────────────────────────────────────┘
                                          │
                                          │ JSON-RPC 2.0 over HTTP/Stdio
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              LAYER 1: TRANSPORT                                      │
│  ┌─────────────────────────┐    ┌─────────────────────────┐                         │
│  │   HTTP Transport        │    │   Stdio Transport       │                         │
│  │   POST /mcp             │    │   Line-delimited JSON   │                         │
│  │   transport.rs:42       │    │   main.rs:28            │                         │
│  └───────────┬─────────────┘    └───────────┬─────────────┘                         │
│              │                              │                                        │
│              └──────────────┬───────────────┘                                        │
│                             │                                                        │
│                             ▼                                                        │
│                    JsonRpcRequest { method, params, id }                            │
└─────────────────────────────┬───────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         LAYER 2: MCP INTERFACE                                       │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │                     McpInterface::handle()                                      │ │
│  │                     interface.rs:59-92                                          │ │
│  │                                                                                 │ │
│  │   "initialize"      → handle_initialize()    → ServerInfo                      │ │
│  │   "ping"            → handle_ping()          → {}                              │ │
│  │   "tools/list"      → handle_tools_list()    → Vec<Tool>                       │ │
│  │   "tools/call"      → handle_tools_call()    → CallToolResult                  │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
│  State Machine: Uninitialized → Initializing → Ready                                │
│                                                                                      │
└─────────────────────────────┬───────────────────────────────────────────────────────┘
                              │
                              │ plexus.call("arbor.tree_render", params)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                        LAYER 3: PLEXUS DISPATCHER                                    │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │                     Plexus::call()                                              │ │
│  │                     plexus.rs:386-446                                           │ │
│  │                                                                                 │ │
│  │   1. parse_method("arbor.tree_render")                                         │ │
│  │      → ("arbor", "tree_render")                                                │ │
│  │                                                                                 │ │
│  │   2. activations.get("arbor")                                                  │ │
│  │      → Arc<dyn ActivationObject>                                               │ │
│  │                                                                                 │ │
│  │   3. activation.call("tree_render", params)                                    │ │
│  │      → Result<PlexusStream, PlexusError>                                       │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
│  Registry: HashMap<String, Arc<dyn ActivationObject>>                               │
│            { "arbor" → Arbor, "cone" → Cone, "health" → Health, ... }               │
│                                                                                      │
└─────────────────────────────┬───────────────────────────────────────────────────────┘
                              │
                              │ activation.call("tree_render", params)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                      LAYER 4: ACTIVATION WRAPPER                                     │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │                  ActivationWrapper<A: Activation>                               │ │
│  │                  plexus.rs:187-248                                              │ │
│  │                                                                                 │ │
│  │   Type erasure bridge:                                                          │ │
│  │   - Converts Activation (has Methods type) → ActivationObject (trait object)   │ │
│  │   - Preserves schema generation via A::Methods                                  │ │
│  │   - Delegates call() to inner Activation                                        │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
└─────────────────────────────┬───────────────────────────────────────────────────────┘
                              │
                              │ arbor.tree_render(tree_id)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                       LAYER 5: ARBOR ACTIVATION                                      │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │    #[hub_methods(namespace = "arbor")]                                          │ │
│  │    impl Arbor { ... }                                                           │ │
│  │    activation.rs:38-433                                                         │ │
│  │                                                                                 │ │
│  │    Methods generated by hub_methods macro:                                      │ │
│  │    ┌──────────────────┬────────────────────────────────────────────┐           │ │
│  │    │ tree_create      │ Create new conversation tree               │           │ │
│  │    │ tree_get         │ Retrieve complete tree with all nodes      │           │ │
│  │    │ tree_list        │ List all active trees                      │           │ │
│  │    │ tree_render      │ Render tree as text visualization          │           │ │
│  │    │ node_create_text │ Create text node in tree                   │           │ │
│  │    │ context_get_path │ Get full path from root to node            │           │ │
│  │    │ ...              │ 20+ more methods                           │           │ │
│  │    └──────────────────┴────────────────────────────────────────────┘           │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │    async fn tree_render(&self, tree_id: TreeId)                                 │ │
│  │        -> impl Stream<Item = ArborEvent>                                        │ │
│  │    activation.rs:417-433                                                        │ │
│  │                                                                                 │ │
│  │    stream! {                                                                    │ │
│  │        match storage.tree_get(&tree_id).await {                                │ │
│  │            Ok(tree) => yield ArborEvent::TreeRender {                          │ │
│  │                tree_id,                                                        │ │
│  │                render: tree.render()   ─────────────────────────┐              │ │
│  │            },                                                    │              │ │
│  │            Err(e) => yield ArborEvent::TreeRender {             │              │ │
│  │                tree_id,                                         │              │ │
│  │                render: format!("Error: {}", e)                  │              │ │
│  │            }                                                    │              │ │
│  │        }                                                        │              │ │
│  │    }                                                            │              │ │
│  └─────────────────────────────────────────────────────────────────┼──────────────┘ │
│                                                                    │                │
└────────────────────────────────────────────────────────────────────┼────────────────┘
                                                                     │
                                                                     ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         LAYER 6: ARBOR STORAGE                                       │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │    ArborStorage (SQLite)                                                        │ │
│  │    storage.rs                                                                   │ │
│  │                                                                                 │ │
│  │    tree_get(&tree_id) → Result<Tree, ArborError>                               │ │
│  │                                                                                 │ │
│  │    Returns Tree struct:                                                         │ │
│  │    ┌────────────────────────────────────────────────────────────────┐          │ │
│  │    │  Tree {                                                        │          │ │
│  │    │      tree_id: Uuid,                                            │          │ │
│  │    │      owner_id: String,                                         │          │ │
│  │    │      ref_count: i64,                                           │          │ │
│  │    │      metadata: Option<Value>,                                  │          │ │
│  │    │      root: Node { id, content: Text|External, children }       │          │ │
│  │    │  }                                                             │          │ │
│  │    └────────────────────────────────────────────────────────────────┘          │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
└─────────────────────────────┬───────────────────────────────────────────────────────┘
                              │
                              │ tree.render()
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         LAYER 7: TREE RENDERING                                      │
│                                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │    Tree::render() → String                                                      │ │
│  │    types.rs:260-302                                                             │ │
│  │                                                                                 │ │
│  │    render_node(node, prefix, is_last) → String                                 │ │
│  │                                                                                 │ │
│  │    Uses box-drawing characters:                                                 │ │
│  │    └── (last child)   ├── (middle child)   │   (continuation)                  │ │
│  │                                                                                 │ │
│  │    Text truncation: 60 chars max, newlines → ↵                                 │ │
│  │    External handles: [source:identifier]                                        │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
│  Example Output:                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────────────┐ │
│  │  └── System: You are a helpful assistant                                       │ │
│  │      ├── User: Hello, how are you?                                             │ │
│  │      │   └── Assistant: I'm doing well, thank you! How can I help?             │ │
│  │      │       └── User: Can you explain recursion?                              │ │
│  │      │           └── Assistant: Recursion is when a function calls itself...   │ │
│  │      └── User: What's the weather?                                             │ │
│  │          └── Assistant: I don't have access to weather data.                   │ │
│  └────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
└─────────────────────────────┬───────────────────────────────────────────────────────┘
                              │
                              │ ArborEvent::TreeRender { tree_id, render }
                              │
                              ▼
                    RESPONSE FLOW (REVERSE)
```

## Response Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                            RESPONSE ASSEMBLY                                         │
│                                                                                      │
│   Layer 7: String render output                                                      │
│       │                                                                              │
│       ▼                                                                              │
│   Layer 5: ArborEvent::TreeRender { tree_id, render }                               │
│       │                                                                              │
│       │  impl ActivationStreamItem for ArborEvent                                   │
│       │      into_plexus_item(provenance, plexus_hash)                              │
│       ▼                                                                              │
│   Layer 4: PlexusStreamItem {                                                        │
│               plexus_hash: "abc123...",                                              │
│               event: PlexusStreamEvent::Data {                                       │
│                   content_type: "arbor.event",                                       │
│                   data: { "tree_id": "...", "render": "└── ..." }                   │
│               }                                                                      │
│           }                                                                          │
│       │                                                                              │
│       │  into_plexus_stream() wraps in Box<dyn Stream>                              │
│       ▼                                                                              │
│   Layer 3: PlexusStream (pinned boxed stream)                                        │
│       │                                                                              │
│       │  Buffer all data events                                                      │
│       ▼                                                                              │
│   Layer 2: CallToolResult {                                                          │
│               content: [{ type: "text", text: "└── ..." }],                         │
│               isError: false                                                         │
│           }                                                                          │
│       │                                                                              │
│       │  Wrap in JsonRpcResponse                                                     │
│       ▼                                                                              │
│   Layer 1: JsonRpcResponse {                                                         │
│               jsonrpc: "2.0",                                                        │
│               id: 42,                                                                │
│               result: { content: [...], isError: false }                            │
│           }                                                                          │
│       │                                                                              │
│       │  HTTP 200 or stdio write                                                     │
│       ▼                                                                              │
│   CLIENT receives rendered tree                                                      │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## Key Data Types

### At Each Layer

| Layer | Input Type | Output Type | File |
|-------|-----------|-------------|------|
| 1. Transport | HTTP POST / stdin line | `JsonRpcRequest` | `transport.rs:42`, `main.rs:28` |
| 2. MCP Interface | `(method, params)` | `Result<Value, McpError>` | `interface.rs:59` |
| 3. Plexus Dispatcher | `"namespace.method", params` | `Result<PlexusStream, PlexusError>` | `plexus.rs:386` |
| 4. Activation Wrapper | `"method", params` | `Result<PlexusStream, PlexusError>` | `plexus.rs:187` |
| 5. Arbor Activation | Typed params (e.g., `TreeId`) | `impl Stream<Item=ArborEvent>` | `activation.rs:417` |
| 6. Arbor Storage | `&TreeId` | `Result<Tree, ArborError>` | `storage.rs` |
| 7. Tree Renderer | `&Tree` | `String` | `types.rs:260` |

### Stream Event Types

```rust
// Plexus-level events (plexus/types.rs:38-82)
enum PlexusStreamEvent {
    Progress { message: String, percentage: Option<f32> },
    Data { content_type: String, data: Value },
    Error { error: String, recoverable: bool },
    Done,
    Guidance { error_type: String, suggestion: String },
}

// Arbor-specific events (activations/arbor/types.rs:353-508)
enum ArborEvent {
    TreeCreated { tree_id, owner_id, metadata },
    TreeData { tree },
    TreeRender { tree_id, render },
    NodeCreated { tree_id, node_id, parent, content },
    ContextPath { tree_id, node_id, path },
    // ... 25+ more variants
}
```

## Stream Conversion Pipeline

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                          STREAM TRANSFORMATION                                │
│                                                                               │
│   Arbor Method                                                                │
│   ┌─────────────────────────────────────────────────────────────────────┐    │
│   │  async fn tree_render(&self, tree_id) -> impl Stream<Item=ArborEvent>│    │
│   └──────────────────────────────────┬──────────────────────────────────┘    │
│                                      │                                        │
│                                      ▼                                        │
│   Stream<Item = ArborEvent>                                                   │
│   ┌─────────────────────────────────────────────────────────────────────┐    │
│   │  ArborEvent::TreeRender { tree_id: "...", render: "└── ..." }       │    │
│   └──────────────────────────────────┬──────────────────────────────────┘    │
│                                      │                                        │
│                                      │ .map(|e| e.into_plexus_item(...))      │
│                                      ▼                                        │
│   Stream<Item = PlexusStreamItem>                                             │
│   ┌─────────────────────────────────────────────────────────────────────┐    │
│   │  PlexusStreamItem {                                                  │    │
│   │      plexus_hash: "abc123",                                          │    │
│   │      event: PlexusStreamEvent::Data {                                │    │
│   │          content_type: "arbor.event",                                │    │
│   │          data: { "tree_id": "...", "render": "└── ..." }            │    │
│   │      }                                                               │    │
│   │  }                                                                   │    │
│   └──────────────────────────────────┬──────────────────────────────────┘    │
│                                      │                                        │
│                                      │ Box::pin(stream)                       │
│                                      ▼                                        │
│   PlexusStream = Pin<Box<dyn Stream<Item = PlexusStreamItem>>>               │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

## Initialization and Registration

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                               STARTUP SEQUENCE                                       │
│                               builder.rs:36-70                                       │
│                                                                                      │
│   1. Create shared storage                                                           │
│      ┌────────────────────────────────────────────────────────────────────────────┐ │
│      │  let arbor_storage = Arc::new(ArborStorage::new(arbor_config).await?);     │ │
│      │                                                                             │ │
│      │  Storage is shared between:                                                 │ │
│      │  - Arbor activation (tree/node operations)                                  │ │
│      │  - Cone activation (conversation context)                                   │ │
│      │  - ClaudeCode activation (session management)                               │ │
│      └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
│   2. Register activations                                                            │
│      ┌────────────────────────────────────────────────────────────────────────────┐ │
│      │  Plexus::new()                                                              │ │
│      │      .register(Health::new())           // namespace: "health"              │ │
│      │      .register(Bash::new())             // namespace: "bash"                │ │
│      │      .register(Arbor::with_storage(     // namespace: "arbor"               │ │
│      │          arbor_storage.clone()                                              │ │
│      │      ))                                                                     │ │
│      │      .register(Cone::new(               // namespace: "cone"                │ │
│      │          cone_config,                                                       │ │
│      │          arbor_storage.clone()                                              │ │
│      │      ).await?)                                                              │ │
│      │      .register(ClaudeCode::new(         // namespace: "claudecode"          │ │
│      │          claudecode_storage                                                 │ │
│      │      ))                                                                     │ │
│      └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
│   3. Data directory structure                                                        │
│      ┌────────────────────────────────────────────────────────────────────────────┐ │
│      │  .substrate/                                                                │ │
│      │  ├── arbor.db      ← Shared tree storage (SQLite)                          │ │
│      │  ├── cone.db       ← Cone-specific data                                    │ │
│      │  └── claudecode.db ← Session data                                          │ │
│      └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
│   4. Start transports                                                                │
│      ┌────────────────────────────────────────────────────────────────────────────┐ │
│      │  Stdio mode (--stdio):                                                      │ │
│      │      stdin → JsonRpcRequest → Plexus → JsonRpcResponse → stdout            │ │
│      │                                                                             │ │
│      │  Server mode (default):                                                     │ │
│      │      WebSocket :4444 → Plexus RPC subscriptions                             │ │
│      │      HTTP :4445      → MCP JSON-RPC                                         │ │
│      └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## Method Dispatch Detail

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                            METHOD DISPATCH                                           │
│                            plexus.rs:386-446                                         │
│                                                                                      │
│   Input: "arbor.tree_render", { "tree_id": "550e8400-..." }                         │
│                                                                                      │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │  Step 1: Parse method name                                                   │   │
│   │                                                                              │   │
│   │  parse_method("arbor.tree_render")                                          │   │
│   │      → Ok(("arbor", "tree_render"))                                         │   │
│   │                                                                              │   │
│   │  Invalid format → Error stream with guidance:                                │   │
│   │      "Call PlexusSchema to see available methods"                           │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                              │                                                       │
│                              ▼                                                       │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │  Step 2: Find activation                                                     │   │
│   │                                                                              │   │
│   │  self.activations.get("arbor")                                              │   │
│   │      → Some(Arc<dyn ActivationObject>)                                      │   │
│   │                                                                              │   │
│   │  Not found → Error stream with guidance:                                     │   │
│   │      "Unknown namespace 'arbor'. Available: [health, bash, arbor, ...]"     │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                              │                                                       │
│                              ▼                                                       │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │  Step 3: Call activation method                                              │   │
│   │                                                                              │   │
│   │  activation.call("tree_render", params).await                               │   │
│   │      → Ok(PlexusStream)  // Success: return stream directly                 │   │
│   │      → Err(e)            // Failure: wrap in guidance stream                │   │
│   │                                                                              │   │
│   │  Error handling (always returns Ok):                                         │   │
│   │      Err(e) → Ok(stream![                                                   │   │
│   │          Guidance { error_type: "activation_error", ... },                  │   │
│   │          Error { error: e.to_string(), recoverable: false },                │   │
│   │          Done                                                                │   │
│   │      ])                                                                      │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
│   Output: Result<PlexusStream, PlexusError>  (always Ok in practice)                │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## Critical Design Patterns

### 1. Streaming-First Architecture

Every activation method returns a stream, enabling:
- **Progress updates** during long operations
- **Chunked data** for large responses
- **Guidance events** for error recovery
- **Consistent interface** for all consumers

```rust
// All methods return streams, never direct values
async fn tree_render(&self, tree_id: TreeId) -> impl Stream<Item = ArborEvent> {
    stream! {
        yield ArborEvent::TreeRender { tree_id, render };
    }
}
```

### 2. Always-Successful Error Handling

`Plexus::call()` returns `Ok(stream)` even for errors:

```rust
// Errors delivered as stream events, not Result::Err
match activation.call(method, params).await {
    Ok(stream) => Ok(stream),
    Err(e) => Ok(error_stream_with_guidance(e)),  // Still Ok!
}
```

This ensures consistent streaming interface regardless of error state.

### 3. Type Erasure with Schema Preservation

```
┌───────────────────────────────────────────────────────────────┐
│   Activation<Methods = ArborMethods>                          │
│       │                                                       │
│       │  ActivationWrapper wraps                              │
│       ▼                                                       │
│   dyn ActivationObject                                        │
│       │                                                       │
│       │  Still can generate schemas via A::Methods            │
│       ▼                                                       │
│   Stored in HashMap<String, Arc<dyn ActivationObject>>        │
└───────────────────────────────────────────────────────────────┘
```

### 4. Provenance Tracking

Each stream item includes its path through the system:

```
"plexus" → "plexus/arbor" → "plexus/arbor/tree_render"
```

Enables debugging and audit trails.

### 5. Hash-Based Cache Invalidation

Every response includes `plexus_hash`:
- Computed from all registered activations and methods
- Clients detect schema changes and refresh
- Enables safe caching of capability discovery

## Example Request: Complete Trace

### Request

```json
{
  "jsonrpc": "2.0",
  "id": 42,
  "method": "tools/call",
  "params": {
    "name": "arbor.tree_render",
    "arguments": {
      "tree_id": "550e8400-e29b-41d4-a716-446655440000"
    }
  }
}
```

### Flow

1. **Transport** (`transport.rs:42`): Parse JSON-RPC, extract method
2. **MCP Interface** (`interface.rs:76`): Route `tools/call` to handler
3. **Plexus** (`plexus.rs:397`): Parse `arbor.tree_render` → `("arbor", "tree_render")`
4. **Registry** (`plexus.rs:412`): Look up Arbor activation
5. **Wrapper** (`plexus.rs:199`): Delegate to `arbor.call("tree_render", {...})`
6. **Arbor** (`activation.rs:422`): Call `storage.tree_get(&tree_id)`
7. **Storage** (`storage.rs`): Query SQLite, build `Tree` struct
8. **Render** (`types.rs:260`): `tree.render()` → box-drawing visualization
9. **Event** (`activation.rs:425`): Yield `ArborEvent::TreeRender { tree_id, render }`
10. **Convert** (`types.rs:515`): `into_plexus_item()` → `PlexusStreamItem::data(...)`
11. **Buffer** (`rmcp_mcp_server.rs:209`): Collect data events
12. **Response** (`rmcp_mcp_server.rs:278`): Build `CallToolResult`

### Response

```json
{
  "jsonrpc": "2.0",
  "id": 42,
  "result": {
    "content": [{
      "type": "text",
      "text": "└── System: You are a helpful assistant\n    ├── User: Hello\n    │   └── Assistant: Hi there!\n    └── User: Goodbye\n        └── Assistant: Farewell!"
    }],
    "isError": false
  }
}
```

## File Reference

| Component | File | Key Lines |
|-----------|------|-----------|
| HTTP Transport | `src/mcp/transport.rs` | 42-92 |
| Stdio Transport | `src/main.rs` | 28-82 |
| MCP Interface | `src/mcp/interface.rs` | 59-92 |
| MCP State Machine | `src/mcp/state.rs` | - |
| Plexus Dispatcher | `src/plexus/plexus.rs` | 386-446 |
| Activation Wrapper | `src/plexus/plexus.rs` | 187-248 |
| Plexus Builder | `src/builder.rs` | 36-70 |
| Arbor Activation | `src/activations/arbor/activation.rs` | 38-433 |
| Tree Render Method | `src/activations/arbor/activation.rs` | 417-433 |
| Tree Render Impl | `src/activations/arbor/types.rs` | 260-302 |
| Arbor Events | `src/activations/arbor/types.rs` | 353-508 |
| Stream Item Trait | `src/activations/arbor/types.rs` | 510-528 |
| Plexus Stream Types | `src/plexus/types.rs` | 36-144 |
| RMCP Example | `examples/rmcp_mcp_server.rs` | 147-302 |
