# Handle Resolution and Rendering System

## Overview

This document defines the architecture for handle resolution and value rendering in Plexus. The system provides:

1. **Plugin Identity** - UUID-based plugin identification for stable handle routing
2. **Handle Resolution** - Lazy value resolution with provenance tracking
3. **Mustache Templating** - Runtime-configurable rendering via a dedicated plugin
4. **Default Rendering** - Plugin-defined default templates stored in database

## Core Algebra

```
method() → Envelope<Handle | Value>
              ↓
         resolve (if Handle)
              ↓
         Envelope<Value>
              ↓
         render (via mustache plugin)
              ↓
           Text
```

## Plugin Identity System

### Plugin UUID

Every plugin instance has a stable UUID:

```rust
#[hub_activation(
    name = "cone",
    plugin_id = "550e8400-e29b-41d4-a716-446655440000",  // explicit
)]
struct Cone { ... }

#[hub_activation(name = "echo")]  // auto-generated UUID
struct Echo { ... }
```

The `plugin_id`:
- Is stable across restarts
- Uniquely identifies plugin instances
- Enables handle routing without path dependency
- Stored in Plexus registry: `plugin_id → current_path`

### Hub Macro Changes

```rust
// Generated by hub-macro
impl Cone {
    pub const PLUGIN_ID: Uuid = uuid!("550e8400-e29b-41d4-a716-446655440000");

    pub fn plugin_id(&self) -> Uuid {
        Self::PLUGIN_ID
    }
}
```

Auto-generation when not specified:
- Derive from plugin name + version hash (deterministic)
- Or generate once and store in config file

## Handle Structure

```rust
struct Handle {
    /// Stable plugin instance identifier
    plugin_id: Uuid,

    /// Method that created this handle (for schema/type lookup)
    method: String,

    /// Address within the plugin's storage
    meta: Vec<String>,
}

impl Display for Handle {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        // Format: {plugin_id}::{method}:meta[0]:meta[1]:...
        write!(f, "{}::{}", self.plugin_id, self.method)?;
        for m in &self.meta {
            write!(f, ":{}", m)?;
        }
        Ok(())
    }
}
```

## Envelope Pattern

Values and handles carry provenance through the pipeline:

```rust
/// Wrapper that carries rendering provenance
struct Envelope<T> {
    /// Who created this / knows how to render it
    origin: Origin,

    /// The actual data
    data: T,
}

struct Origin {
    /// Plugin that can render this value
    plugin_id: Uuid,

    /// Method context (for schema lookup)
    method: String,
}
```

### Flow

1. **Method returns** - Values wrapped with method's origin
2. **Handle in event** - Handle carries its own origin (plugin_id, method)
3. **Resolution** - Produces `Envelope<Value>` preserving handle's origin
4. **Rendering** - Uses origin to find template, calls mustache plugin

## Mustache Plugin

A dedicated top-level plugin for template rendering:

```rust
#[hub_activation(
    name = "mustache",
    plugin_id = "00000000-0000-0000-0000-000000000001",  // well-known ID
)]
struct Mustache {
    storage: MustacheStorage,  // SQLite for templates
}

#[hub_method]
impl Mustache {
    /// Render a value using a template
    async fn render(
        &self,
        plugin_id: Uuid,     // which plugin's template
        method: String,      // which method's output
        template_name: Option<String>,  // specific template or "default"
        value: Value,
    ) -> String;

    /// Register a template for a plugin/method
    async fn register_template(
        &self,
        plugin_id: Uuid,
        method: String,
        name: String,        // e.g., "default", "compact", "verbose"
        template: String,    // mustache template
    );

    /// List templates for a plugin
    async fn list_templates(
        &self,
        plugin_id: Uuid,
    ) -> Vec<TemplateInfo>;

    /// Get a specific template
    async fn get_template(
        &self,
        plugin_id: Uuid,
        method: String,
        name: String,
    ) -> Option<String>;
}
```

### Template Storage Schema

```sql
CREATE TABLE templates (
    id TEXT PRIMARY KEY,
    plugin_id TEXT NOT NULL,      -- UUID of plugin
    method TEXT NOT NULL,         -- method name
    name TEXT NOT NULL,           -- template name (e.g., "default")
    template TEXT NOT NULL,       -- mustache template content
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,

    UNIQUE(plugin_id, method, name)
);

CREATE INDEX idx_templates_plugin ON templates(plugin_id);
CREATE INDEX idx_templates_lookup ON templates(plugin_id, method, name);
```

### Default Templates

Plugins register their default templates on initialization:

```rust
impl Cone {
    async fn register_default_templates(&self, mustache: &Mustache) {
        // Chat message template
        mustache.register_template(
            Self::PLUGIN_ID,
            "chat",
            "default",
            "[{{role}}]: {{content}}"
        ).await;

        // Verbose template
        mustache.register_template(
            Self::PLUGIN_ID,
            "chat",
            "verbose",
            "--- {{role}} ({{model}}) ---\n{{content}}\n---"
        ).await;
    }
}

impl Bash {
    async fn register_default_templates(&self, mustache: &Mustache) {
        mustache.register_template(
            Self::PLUGIN_ID,
            "execute",
            "default",
            "```\n$ {{command}}\n{{stdout}}{{#stderr}}\nSTDERR: {{stderr}}{{/stderr}}\n```"
        ).await;
    }
}
```

## Resolution and Rendering Flow

### Client-Side Rendering (External)

External clients (Synapse, UI) control their own rendering:

```
1. Call method → Stream<Event>
2. Extract handles from events
3. For custom rendering:
   - Call plexus.resolve(handle) → Value
   - Apply client's own template
4. For default rendering:
   - Call plexus.render(handle) → Text
   - Or: Call mustache.render(origin, value) directly
```

### Plugin-Side Rendering (Internal)

Plugins like Cone that build LLM context:

```rust
impl Cone {
    async fn build_context(&self, tree_id: TreeId, head: NodeId) -> Vec<Message> {
        let nodes = self.arbor.get_path(tree_id, head).await?;
        let mustache = self.plexus.get_plugin::<Mustache>()?;

        let mut messages = Vec::new();
        for node in nodes {
            let text = match &node.data {
                NodeData::Text { content } => content.clone(),
                NodeData::External { handle } => {
                    // Resolve handle to value
                    let resolved = self.plexus.resolve(handle).await?;

                    // Render using default template
                    mustache.render(
                        resolved.origin.plugin_id,
                        resolved.origin.method,
                        None,  // use "default"
                        resolved.value,
                    ).await?
                }
            };
            messages.push(Message { role: "user", content: text });
        }
        messages
    }
}
```

### Plexus-Level Convenience Methods

```rust
impl Plexus {
    /// Resolve a handle to its value
    async fn resolve(&self, handle: &Handle) -> Result<Envelope<Value>> {
        let plugin_path = self.registry.lookup(handle.plugin_id)?;
        let value = self.call(&plugin_path, "resolve_handle", handle).await?;

        Ok(Envelope {
            origin: Origin {
                plugin_id: handle.plugin_id,
                method: handle.method.clone(),
            },
            data: value,
        })
    }

    /// Resolve and render with default template
    async fn render(&self, handle: &Handle) -> Result<String> {
        let resolved = self.resolve(handle).await?;
        let mustache = self.get_plugin::<Mustache>()?;

        mustache.render(
            resolved.origin.plugin_id,
            resolved.origin.method,
            None,
            resolved.data,
        ).await
    }

    /// Render an already-resolved value
    async fn render_value(&self, envelope: Envelope<Value>) -> Result<String> {
        let mustache = self.get_plugin::<Mustache>()?;

        mustache.render(
            envelope.origin.plugin_id,
            envelope.origin.method,
            None,
            envelope.data,
        ).await
    }
}
```

## Plugin Registry

Maps plugin UUIDs to current paths:

```rust
struct PluginRegistry {
    by_id: HashMap<Uuid, PluginEntry>,
    by_path: HashMap<String, Uuid>,
}

struct PluginEntry {
    id: Uuid,
    path: String,
    plugin_type: String,  // "cone", "bash", etc.
}

impl PluginRegistry {
    fn lookup(&self, id: Uuid) -> Option<&str> {
        self.by_id.get(&id).map(|e| e.path.as_str())
    }

    fn register(&mut self, id: Uuid, path: String, plugin_type: String) {
        self.by_id.insert(id, PluginEntry { id, path: path.clone(), plugin_type });
        self.by_path.insert(path, id);
    }
}
```

## Runtime Configuration

Templates can be modified at runtime:

```bash
# List templates for a plugin
synapse mustache list_templates --plugin-id "550e8400-..."

# Update a template
synapse mustache register_template \
    --plugin-id "550e8400-..." \
    --method "chat" \
    --name "default" \
    --template "[{{role}}] {{content}}"

# Use a specific template
synapse mustache render \
    --plugin-id "550e8400-..." \
    --method "chat" \
    --template-name "verbose" \
    --value '{"role": "user", "content": "hello"}'
```

## Implementation Phases

### Phase 1: Plugin ID System
- Add `plugin_id` to hub-macro attributes
- Generate UUID constant in plugin impl
- Add `plugin_id()` method to Activation trait
- Create PluginRegistry in Plexus
- Update plugin registration to populate registry

### Phase 2: Handle Updates
- Update Handle struct to use plugin_id instead of plugin name
- Update handle parsing/display
- Update resolve routing to use registry lookup
- Add Envelope and Origin types

### Phase 3: Mustache Plugin
- Create mustache activation with SQLite storage
- Implement render, register_template, list_templates, get_template
- Add as core plugin in Plexus builder

### Phase 4: Default Template Registration
- Add register_default_templates to plugins with handles
- Call during plugin initialization
- Update Cone, Bash, ClaudeCode with default templates

### Phase 5: Integration
- Add resolve/render convenience methods to Plexus
- Update Cone context building to use mustache
- Update ClaudeCode context building
- Add CLI commands to Synapse for template management

## Migration

Existing handles use plugin name. Migration path:

1. Registry supports lookup by name OR UUID (transition period)
2. New handles use UUID
3. Old handles resolved via name → UUID lookup
4. Eventually deprecate name-based lookup

## Security Considerations

- Templates are stored per-plugin, isolated by plugin_id
- Only the plugin that owns a template can modify it (or admin)
- Template rendering is sandboxed (mustache is logic-less)
- Handle resolution validates plugin_id exists in registry
