// Auto-generated by hub-codegen
// Do not edit manually

/** Events emitted by Arbor operations */
export type ArborEvent = ArborEvent_TreeCreated | ArborEvent_TreeDeleted | ArborEvent_TreeUpdated | ArborEvent_TreeList | ArborEvent_TreeClaimed | ArborEvent_TreeReleased | ArborEvent_TreeScheduledDeletion | ArborEvent_TreeArchived | ArborEvent_TreeRefs | ArborEvent_NodeCreated | ArborEvent_NodeUpdated | ArborEvent_NodeDeleted | ArborEvent_NodeClaimed | ArborEvent_NodeReleased | ArborEvent_NodeScheduledDeletion | ArborEvent_NodeArchived | ArborEvent_NodeRefs | ArborEvent_TreeData | ArborEvent_TreeSkeleton | ArborEvent_NodeData | ArborEvent_NodeChildren | ArborEvent_NodeParent | ArborEvent_ContextPath | ArborEvent_ContextPathData | ArborEvent_ContextHandles | ArborEvent_ContextLeaves | ArborEvent_TreesScheduled | ArborEvent_NodesScheduled | ArborEvent_TreesArchived | ArborEvent_TreeRender;

export interface ArborEvent_TreeCreated {
  type: 'tree_created';
  treeId: UUID;
}

export interface ArborEvent_TreeDeleted {
  type: 'tree_deleted';
  treeId: UUID;
}

export interface ArborEvent_TreeUpdated {
  type: 'tree_updated';
  treeId: UUID;
}

export interface ArborEvent_TreeList {
  type: 'tree_list';
  treeIds: UUID[];
}

export interface ArborEvent_TreeClaimed {
  type: 'tree_claimed';
  newCount: number;
  ownerId: string;
  treeId: UUID;
}

export interface ArborEvent_TreeReleased {
  type: 'tree_released';
  newCount: number;
  ownerId: string;
  treeId: UUID;
}

export interface ArborEvent_TreeScheduledDeletion {
  type: 'tree_scheduled_deletion';
  scheduledAt: number;
  treeId: UUID;
}

export interface ArborEvent_TreeArchived {
  type: 'tree_archived';
  archivedAt: number;
  treeId: UUID;
}

export interface ArborEvent_TreeRefs {
  type: 'tree_refs';
  refs: ResourceRefs;
  treeId: UUID;
}

export interface ArborEvent_NodeCreated {
  type: 'node_created';
  nodeId: UUID;
  parent: UUID | null;
  treeId: UUID;
}

export interface ArborEvent_NodeUpdated {
  type: 'node_updated';
  newId: UUID;
  oldId: UUID;
  treeId: UUID;
}

export interface ArborEvent_NodeDeleted {
  type: 'node_deleted';
  nodeId: UUID;
  treeId: UUID;
}

export interface ArborEvent_NodeClaimed {
  type: 'node_claimed';
  newCount: number;
  nodeId: UUID;
  ownerId: string;
  treeId: UUID;
}

export interface ArborEvent_NodeReleased {
  type: 'node_released';
  newCount: number;
  nodeId: UUID;
  ownerId: string;
  treeId: UUID;
}

export interface ArborEvent_NodeScheduledDeletion {
  type: 'node_scheduled_deletion';
  nodeId: UUID;
  scheduledAt: number;
  treeId: UUID;
}

export interface ArborEvent_NodeArchived {
  type: 'node_archived';
  archivedAt: number;
  nodeId: UUID;
  treeId: UUID;
}

export interface ArborEvent_NodeRefs {
  type: 'node_refs';
  nodeId: UUID;
  refs: ResourceRefs;
  treeId: UUID;
}

export interface ArborEvent_TreeData {
  type: 'tree_data';
  tree: Tree;
}

export interface ArborEvent_TreeSkeleton {
  type: 'tree_skeleton';
  skeleton: TreeSkeleton;
}

export interface ArborEvent_NodeData {
  type: 'node_data';
  node: Node;
  treeId: UUID;
}

export interface ArborEvent_NodeChildren {
  type: 'node_children';
  children: UUID[];
  nodeId: UUID;
  treeId: UUID;
}

export interface ArborEvent_NodeParent {
  type: 'node_parent';
  nodeId: UUID;
  parent: UUID | null;
  treeId: UUID;
}

export interface ArborEvent_ContextPath {
  type: 'context_path';
  path: UUID[];
  treeId: UUID;
}

export interface ArborEvent_ContextPathData {
  type: 'context_path_data';
  nodes: Node[];
  treeId: UUID;
}

export interface ArborEvent_ContextHandles {
  type: 'context_handles';
  handles: Handle[];
  treeId: UUID;
}

export interface ArborEvent_ContextLeaves {
  type: 'context_leaves';
  leaves: UUID[];
  treeId: UUID;
}

export interface ArborEvent_TreesScheduled {
  type: 'trees_scheduled';
  treeIds: UUID[];
}

export interface ArborEvent_NodesScheduled {
  type: 'nodes_scheduled';
  nodeIds: UUID[];
  treeId: UUID;
}

export interface ArborEvent_TreesArchived {
  type: 'trees_archived';
  treeIds: UUID[];
}

export interface ArborEvent_TreeRender {
  type: 'tree_render';
  render: string;
  treeId: UUID;
}


/** Stream events from bash command execution */
export type BashEvent = BashEvent_Stdout | BashEvent_Stderr | BashEvent_Exit;

/** Standard output line */
export interface BashEvent_Stdout {
  type: 'stdout';
  line: string;
}

/** Standard error line */
export interface BashEvent_Stderr {
  type: 'stderr';
  line: string;
}

/** Exit code when process completes */
export interface BashEvent_Exit {
  type: 'exit';
  code: number;
}


/** Type of celestial body */
export type BodyType = BodyType_Star | BodyType_Planet | BodyType_DwarfPlanet | BodyType_Moon;

export interface BodyType_Star {
  value: 'star';
}

export interface BodyType_Planet {
  value: 'planet';
}

export interface BodyType_DwarfPlanet {
  value: 'dwarf_planet';
}

export interface BodyType_Moon {
  value: 'moon';
}


/** Event for call() method - wraps dynamic responses from routed methods

This allows plexus.call to follow the uniform streaming pattern where
all methods return streams and errors are stream events. */
export type CallEvent = CallEvent_Data | CallEvent_Progress | CallEvent_Error;

/** Forwarded data from the called method */
export interface CallEvent_Data {
  type: 'data';
  /** The actual response content (dynamic based on called method) */
  content: unknown;
  /** Content type identifier (e.g., "echo.echo", "health.status") */
  contentType: string;
}

/** Progress update during long-running operations */
export interface CallEvent_Progress {
  type: 'progress';
  /** Human-readable progress message */
  message: string;
  /** Optional completion percentage (0.0 - 100.0) */
  percentage: number | null;
}

/** Error from routing or method execution */
export interface CallEvent_Error {
  type: 'error';
  /** Optional error code */
  code: string | null;
  /** Error message */
  message: string;
}


export interface Capabilities {
  contextWindow: number;
  functions?: boolean;
  jsonMode?: boolean;
  maxOutputTokens: number;
  multimodal?: boolean;
  streaming?: boolean;
  systemPrompt?: boolean;
  vision?: boolean;
}

/** A changelog entry documenting a plexus hash transition */
export interface ChangelogEntry {
  /** Who/what added this entry */
  author?: string | null;
  /** Unix timestamp when this entry was added */
  createdAt: number;
  /** Detailed list of changes (bullet points) */
  details?: string[];
  /** The plexus_hash this entry documents */
  hash: string;
  /** The previous hash this transitioned from (None for initial entry) */
  previousHash?: string | null;
  /** Reference to a queue item this changelog completes */
  queueId?: string | null;
  /** Short summary of changes (one line) */
  summary: string;
}

/** Events emitted by changelog operations */
export type ChangelogEvent = ChangelogEvent_EntryAdded | ChangelogEvent_Entries | ChangelogEvent_Status | ChangelogEvent_StartupCheck | ChangelogEvent_QueueAdded | ChangelogEvent_QueueUpdated | ChangelogEvent_QueueEntries | ChangelogEvent_QueueItem;

/** Entry was added */
export interface ChangelogEvent_EntryAdded {
  type: 'entry_added';
  entry: ChangelogEntry;
}

/** List of entries */
export interface ChangelogEvent_Entries {
  type: 'entries';
  entries: ChangelogEntry[];
}

/** Current state check result */
export interface ChangelogEvent_Status {
  type: 'status';
  currentHash: string;
  entry: ChangelogEntry | null;
  isDocumented: boolean;
  previousHash: string | null;
}

/** Startup check result */
export interface ChangelogEvent_StartupCheck {
  type: 'startup_check';
  currentHash: string;
  hashChanged: boolean;
  isDocumented: boolean;
  message: string;
  previousHash: string | null;
}

/** Queue item was added */
export interface ChangelogEvent_QueueAdded {
  type: 'queue_added';
  entry: QueueEntry;
}

/** Queue item was updated (e.g., marked complete) */
export interface ChangelogEvent_QueueUpdated {
  type: 'queue_updated';
  entry: QueueEntry;
}

/** List of queue items */
export interface ChangelogEvent_QueueEntries {
  type: 'queue_entries';
  entries: QueueEntry[];
}

/** Single queue item */
export interface ChangelogEvent_QueueItem {
  type: 'queue_item';
  entry: QueueEntry | null;
}


/** Events emitted during cone.chat (streaming) */
export type ChatEvent = ChatEvent_ChatStart | ChatEvent_ChatContent | ChatEvent_ChatComplete | ChatEvent_Error;

/** Chat response started */
export interface ChatEvent_ChatStart {
  type: 'chat_start';
  coneId: string;
  /** Position of the user message node */
  userPosition: Position;
}

/** Chat content chunk (streaming) */
export interface ChatEvent_ChatContent {
  type: 'chat_content';
  coneId: string;
  content: string;
}

/** Chat response complete */
export interface ChatEvent_ChatComplete {
  type: 'chat_complete';
  coneId: string;
  /** The new head position (tree + response node) */
  newHead: Position;
  /** Total tokens used (if available) */
  usage: ChatUsage | null;
}

export interface ChatEvent_Error {
  type: 'error';
  message: string;
}


/** Token usage information */
export interface ChatUsage {
  inputTokens?: number | null;
  outputTokens?: number | null;
  totalTokens?: number | null;
}

/** Summary of a child plugin */
export interface ChildSummary {
  /** Human-readable description */
  description: string;
  /** Content hash for cache invalidation */
  hash: string;
  /** The child's namespace */
  namespace: string;
}

/** ClaudeCode session configuration */
export interface ClaudeCodeConfig {
  /** Claude Code's internal session ID (for --resume) */
  claudeSessionId?: string | null;
  /** Created timestamp */
  createdAt: number;
  /** The canonical head - current position in conversation tree */
  head: Position;
  /** Unique identifier for this session */
  id: string;
  /** MCP server configuration (JSON) */
  mcpConfig?: unknown;
  /** Additional metadata */
  metadata?: unknown;
  /** Model to use */
  model: Model;
  /** Human-readable name */
  name: string;
  /** System prompt / instructions */
  systemPrompt?: string | null;
  /** Last updated timestamp */
  updatedAt: number;
  /** Working directory for Claude Code */
  workingDir: string;
}

/** Lightweight session info (for listing) */
export interface ClaudeCodeInfo {
  claudeSessionId?: string | null;
  createdAt: number;
  head: Position;
  id: string;
  model: Model;
  name: string;
  workingDir: string;
}

/** Cone configuration - defines an cone's identity and behavior */
export interface ConeConfig {
  /** Created timestamp */
  createdAt: number;
  /** The canonical head - current position in conversation tree
This couples tree_id and node_id together */
  head: Position;
  /** Unique identifier for this cone */
  id: string;
  /** Additional configuration metadata */
  metadata?: unknown;
  /** Model ID to use (e.g., "gpt-4o-mini", "claude-3-haiku-20240307") */
  modelId: string;
  /** Human-readable name */
  name: string;
  /** System prompt / instructions for the cone */
  systemPrompt?: string | null;
  /** Last updated timestamp */
  updatedAt: number;
}

/** Lightweight cone info (for listing) */
export interface ConeInfo {
  createdAt: number;
  head: Position;
  id: string;
  modelId: string;
  name: string;
}

export interface Constraints {
  maxFunctionCallsPerMessage?: number | null;
  maxImageSizeMb?: number | null;
  maxImagesPerMessage?: number | null;
  supportedImageFormats?: string[];
}

/** Result of cone.create */
export type CreateResult = CreateResult_ConeCreated | CreateResult_Error;

export interface CreateResult_ConeCreated {
  type: 'cone_created';
  coneId: string;
  /** Initial position (tree + root node) */
  head: Position;
}

export interface CreateResult_Error {
  type: 'error';
  message: string;
}


/** Currency for pricing */
export type Currency = Currency_USD | Currency_EUR | Currency_GBP;

export interface Currency_USD {
  value: 'USD';
}

export interface Currency_EUR {
  value: 'EUR';
}

export interface Currency_GBP {
  value: 'GBP';
}


/** Result of cone.delete */
export type DeleteResult = DeleteResult_ConeDeleted | DeleteResult_Error;

export interface DeleteResult_ConeDeleted {
  type: 'cone_deleted';
  coneId: string;
}

export interface DeleteResult_Error {
  type: 'error';
  message: string;
}


/** Events from echo operations */
export type EchoEvent = ;


/** Result of forking a session */
export type ForkResult = ForkResult_Forked | ForkResult_Error;

export interface ForkResult_Forked {
  type: 'forked';
  head: Position;
  id: string;
}

export interface ForkResult_Error {
  type: 'error';
  message: string;
}


/** Result of cone.get */
export type GetResult = GetResult_ConeData | GetResult_Error;

export interface GetResult_ConeData {
  type: 'cone_data';
  cone: ConeConfig;
}

export interface GetResult_Error {
  type: 'error';
  message: string;
}


/** Handle pointing to external data with versioning

Display format: `{plugin_id}@{version}::{method}:meta[0]:meta[1]:...`

Examples:
- `550e8400-e29b-41d4-a716-446655440000@1.0.0::chat:msg-123:user:bob`
- `123e4567-e89b-12d3-a456-426614174000@1.0.0::execute:cmd-789` */
export interface Handle {
  /** Metadata parts - variable length list of strings
For messages: typically [message_uuid, role, optional_extra...] */
  meta?: string[];
  /** Creation method that produced this handle (e.g., "chat", "execute") */
  method: string;
  /** Stable plugin instance identifier (UUID) */
  pluginId: string;
  /** Plugin version (semantic version: "MAJOR.MINOR.PATCH")
Used for schema/type lookup */
  version: string;
}

export type HashEvent = ;


/** Stream events from health check

This is a plain domain type - no trait implementations needed.
The caller (Plexus) wraps this with metadata when streaming. */
export type HealthEvent = ;


/** Result of cone.list */
export type ListResult = ListResult_ConeList | ListResult_Error;

export interface ListResult_ConeList {
  type: 'cone_list';
  cones: ConeInfo[];
}

export interface ListResult_Error {
  type: 'error';
  message: string;
}


/** Message builder format - determines how messages are structured for the API */
export type MessageFormat = ;


/** Schema for a single method exposed by a plugin */
export interface MethodSchema {
  /** Human-readable description of what this method does */
  description: string;
  /** Content hash of the method definition (for cache invalidation)
Generated by hashing the method signature within hub-macro */
  hash: string;
  /** Method name (e.g., "echo", "check") */
  name: string;
  /** JSON Schema for the method's parameters (None if no params) */
  params?: Schema | null;
  /** JSON Schema for the method's return type (None if not specified) */
  returns?: Schema | null;
  /** Whether this method streams multiple events (true) or returns a single result (false)

- `streaming: true` → returns `AsyncGenerator<T>` (multiple events)
- `streaming: false` → returns `Promise<T>` (single event, collected)

All methods use the same streaming protocol under the hood, but this flag
tells clients how to present the result. */
  streaming?: boolean;
}

/** Model selection for Claude Code */
export type Model = Model_Opus | Model_Sonnet | Model_Haiku;

export interface Model_Opus {
  value: 'opus';
}

export interface Model_Sonnet {
  value: 'sonnet';
}

export interface Model_Haiku {
  value: 'haiku';
}


/** Serializable model information */
export interface ModelExport {
  /** Model capabilities */
  capabilities: Capabilities;
  /** Model constraints */
  constraints: Constraints;
  /** Model family (e.g., "claude", "gpt") */
  family: string;
  /** Model identifier */
  id: string;
  /** Lab/organization that created the model */
  lab?: string | null;
  /** Human-readable name */
  name: string;
  /** Pricing information */
  pricing: Pricing;
  /** Service this model uses */
  service: string;
  /** Verification status */
  status: VerificationStatus;
  /** Use cases this model is suited for */
  useCases: string[];
  /** Variant (e.g., "haiku", "sonnet", "opus") */
  variant?: string | null;
  /** Version string if available */
  version?: string | null;
}

/** Events from mustache operations */
export type MustacheEvent = ;


/** A node in the conversation tree */
export interface Node {
  /** Archived timestamp (Unix seconds) */
  archivedAt?: number | null;
  /** Child nodes (in order) */
  children: UUID[];
  /** Creation timestamp (Unix seconds) */
  createdAt: number;
  /** Node data (handle or built-in) */
  data: NodeType;
  /** Unique identifier for this node */
  id: UUID;
  /** Optional metadata */
  metadata?: unknown;
  /** Parent node (None for root) */
  parent?: UUID | null;
  /** Reference count information */
  refs?: ResourceRefs | null;
  /** Scheduled deletion timestamp (Unix seconds) */
  scheduledDeletionAt?: number | null;
  /** Reference counting state */
  state?: ResourceState | null;
}

/** Lightweight node representation (just structure, no data) */
export interface NodeSkeleton {
  children: UUID[];
  id: UUID;
  /** Type indicator (but not the actual data) */
  nodeType: string;
  parent?: UUID | null;
}

/** Node type discriminator */
export type NodeType = NodeType_Text | NodeType_External;

/** Built-in text node (data stored in Arbor) */
export interface NodeType_Text {
  type: 'text';
  content: string;
}

/** External data reference */
export interface NodeType_External {
  type: 'external';
  handle: Handle;
}


/** A plugin's schema with methods and child summaries.

Children are represented as summaries (namespace, description, hash) rather
than full recursive schemas. This enables lazy traversal - clients can fetch
child schemas individually via `{namespace}.schema`.

- Leaf plugins have `children = None`
- Hub plugins have `children = Some([ChildSummary, ...])` */
export interface PluginSchema {
  /** Child plugin summaries (None = leaf plugin, Some = hub plugin) */
  children?: unknown[] | null;
  /** Short description of the plugin (max 15 words) */
  description: string;
  /** Content hash computed from methods + children hashes (for cache invalidation)
This hash changes when any method or child plugin changes */
  hash: string;
  /** Detailed description of the plugin (optional) */
  longDescription?: string | null;
  /** Methods exposed by this plugin */
  methods: MethodSchema[];
  /** The plugin's namespace (e.g., "echo", "plexus") */
  namespace: string;
  /** The plugin's version (e.g., "1.0.0") */
  version: string;
}

/** A position in the context tree - couples tree_id and node_id together.
This ensures we always have a valid reference into a specific tree. */
export interface Position {
  /** The specific node within the tree */
  nodeId: UUID;
  /** The tree containing this position */
  treeId: UUID;
}

export interface Pricing {
  cachedInputPer1kTokens?: number | null;
  currency?: Currency;
  inputPer1kTokens: number;
  outputPer1kTokens: number;
}

/** A queued change - a planned modification that systems should implement */
export interface QueueEntry {
  /** Unix timestamp when this was completed */
  completedAt?: number | null;
  /** The hash where this change was implemented (set when completed) */
  completedHash?: string | null;
  /** Unix timestamp when this was queued */
  createdAt: number;
  /** Description of the planned change */
  description: string;
  /** Unique identifier for this queue item */
  id: string;
  /** Current status of the queue item */
  status: QueueStatus;
  /** Tags to identify which systems this change affects (e.g., "frontend", "api", "breaking") */
  tags?: string[];
}

/** Status of a queued change */
export type QueueStatus = ;


/** Serializable rate limits */
export interface RateLimitsExport {
  concurrentRequests?: number | null;
  requestsPerMinute?: number | null;
  tokensPerMinute?: number | null;
}

/** Complete registry export - all services, families, and models in one structure */
export interface RegistryExport {
  /** All model families (e.g., "claude", "gpt", "deepseek") */
  families: string[];
  /** All available models */
  models: ModelExport[];
  /** All available services */
  services: ServiceExport[];
  /** Summary statistics */
  stats: RegistryStats;
}

/** Result of cone.registry */
export type RegistryResult = RegistryResult_Registry;

export interface RegistryResult_Registry {
  type: 'registry';
}


/** Summary statistics about the registry */
export interface RegistryStats {
  /** Total number of model families */
  familyCount: number;
  /** Total number of models */
  modelCount: number;
  /** Total number of services */
  serviceCount: number;
  /** Number of unverified models */
  unverifiedCount: number;
  /** Number of verified models */
  verifiedCount: number;
}

/** Reference counting information for a resource */
export interface ResourceRefs {
  /** Who owns references (owner_id -> count) */
  owners: Record<string, unknown>;
  /** Total reference count */
  refCount: number;
}

/** Resource state in deletion lifecycle */
export type ResourceState = ;


export type Schema = unknown;

/** Serializable service information */
export interface ServiceExport {
  /** Base URL for the API */
  baseUrl: string;
  /** Message format type */
  messageFormat: MessageFormat;
  /** Number of models using this service */
  modelCount: number;
  /** Service identifier (e.g., "openai", "anthropic") */
  name: string;
  /** Rate limits if configured */
  rateLimits?: RateLimitsExport | null;
}

/** Result of cone.set_head */
export type SetHeadResult = SetHeadResult_HeadUpdated | SetHeadResult_Error;

export interface SetHeadResult_HeadUpdated {
  type: 'head_updated';
  coneId: string;
  newHead: Position;
  oldHead: Position;
}

export interface SetHeadResult_Error {
  type: 'error';
  message: string;
}


/** Events from solar system observations */
export type SolarEvent = ;


/** Information about a registered template */
export interface TemplateInfo {
  /** When the template was created (Unix timestamp) */
  createdAt: number;
  /** Unique template ID */
  id: string;
  /** Method this template is for */
  method: string;
  /** Template name (e.g., "default", "compact", "verbose") */
  name: string;
  /** Plugin that owns this template */
  pluginId: string;
  /** When the template was last updated (Unix timestamp) */
  updatedAt: number;
}

/** A conversation tree */
export interface Tree {
  /** Archived timestamp (Unix seconds) */
  archivedAt?: number | null;
  /** Creation timestamp (Unix seconds) */
  createdAt: number;
  /** Unique identifier for this tree */
  id: UUID;
  /** Optional tree-level metadata (name, description, etc.) */
  metadata?: unknown;
  /** All nodes in the tree (NodeId -> Node) */
  nodes: Record<string, unknown>;
  /** Reference count information */
  refs?: ResourceRefs | null;
  /** Root node ID */
  root: UUID;
  /** Scheduled deletion timestamp (Unix seconds) */
  scheduledDeletionAt?: number | null;
  /** Reference counting state */
  state?: ResourceState | null;
  /** Last modified timestamp (Unix seconds) */
  updatedAt: number;
}

/** Lightweight tree structure */
export interface TreeSkeleton {
  id: UUID;
  nodes: Record<string, unknown>;
  root: UUID;
  state?: ResourceState | null;
}

export type UUID = string;

/** Verification status for a model configuration */
export type VerificationStatus = ;

