//! Clean test: User only writes struct, events, and methods.
//! The macro generates everything else.

use futures::Stream;
use hub_macro::{hub_methods, StreamEvent};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

// ============================================================================
// What the user writes: Event types
// ============================================================================

/// Events emitted by the echo stream
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, StreamEvent)]
#[stream_event(content_type = "echo.event", crate_path = "substrate")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum EchoEvent {
    /// A chunk of echoed data
    Chunk { data: String },
    /// Stream complete
    #[terminal]
    Done { total_len: usize },
}

/// Status response
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, StreamEvent)]
#[stream_event(content_type = "echo.status", crate_path = "substrate")]
pub struct StatusResponse {
    pub uptime_secs: u64,
    pub version: String,
}

// ============================================================================
// What the user writes: Plugin struct and methods
// ============================================================================

#[derive(Clone)]
pub struct EchoPlugin {
    start_time: std::time::Instant,
}

impl EchoPlugin {
    pub fn new() -> Self {
        Self { start_time: std::time::Instant::now() }
    }
}

#[hub_methods(namespace = "echo", version = "1.0.0", description = "Echo plugin", crate_path = "substrate")]
impl EchoPlugin {
    /// Echo back the input as a stream
    #[hub_macro::hub_method]
    async fn echo(&self, message: String) -> impl Stream<Item = EchoEvent> + Send + 'static {
        let total_len = message.len();
        async_stream::stream! {
            for word in message.split_whitespace() {
                yield EchoEvent::Chunk { data: word.to_string() };
            }
            yield EchoEvent::Done { total_len };
        }
    }

    /// Get current status
    #[hub_macro::hub_method]
    async fn status(&self) -> impl Stream<Item = StatusResponse> + Send + 'static {
        let uptime = self.start_time.elapsed().as_secs();
        async_stream::stream! {
            yield StatusResponse {
                uptime_secs: uptime,
                version: "1.0.0".to_string(),
            };
        }
    }
}

// ============================================================================
// Tests - everything below here uses generated code
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use futures::StreamExt;
    use substrate::plexus::{Activation, Plexus};

    #[test]
    fn test_generated_method_enum() {
        // EchoPluginMethod is generated by the macro (struct name + Method)
        let names = EchoPluginMethod::all_method_names();
        assert!(names.contains(&"echo"));
        assert!(names.contains(&"status"));
    }

    #[test]
    fn test_generated_namespace_constant() {
        assert_eq!(EchoPlugin::NAMESPACE, "echo");
    }

    #[test]
    fn test_activation_trait_implemented() {
        let plugin = EchoPlugin::new();
        assert_eq!(plugin.namespace(), "echo");
        assert_eq!(plugin.version(), "1.0.0");
        assert_eq!(plugin.description(), "Echo plugin");
        assert!(plugin.methods().contains(&"echo"));
        assert!(plugin.methods().contains(&"status"));
    }

    #[test]
    fn test_method_help() {
        let plugin = EchoPlugin::new();
        let help = plugin.method_help("echo");
        assert!(help.is_some());
        assert!(help.unwrap().contains("Echo"));
    }

    #[test]
    fn test_register_and_query_schema() {
        let plexus = Plexus::new().register(EchoPlugin::new());

        // Schema is generated from EchoMethod enum
        let schema = plexus.get_activation_schema("echo");
        assert!(schema.is_some());

        let schema = schema.unwrap();
        let methods = schema.list_methods();
        assert!(methods.contains(&"echo".to_string()));
        assert!(methods.contains(&"status".to_string()));

        println!("Schema:\n{}", serde_json::to_string_pretty(&schema).unwrap());
    }

    #[test]
    fn test_stream_event_terminal() {
        use substrate::plugin_system::types::ActivationStreamItem;

        let chunk = EchoEvent::Chunk { data: "hi".into() };
        let done = EchoEvent::Done { total_len: 2 };

        assert!(!chunk.is_terminal());
        assert!(done.is_terminal());
    }

    #[test]
    fn test_struct_event_always_terminal() {
        use substrate::plugin_system::types::ActivationStreamItem;

        let status = StatusResponse { uptime_secs: 10, version: "1.0".into() };
        assert!(status.is_terminal()); // Structs are always terminal
    }

    #[tokio::test]
    async fn test_call_method() {
        substrate::plexus::PlexusContext::init("test".into());
        let plexus = Plexus::new().register(EchoPlugin::new());

        let stream = plexus
            .call("echo.echo", serde_json::json!({"message": "hello world"}))
            .await
            .unwrap();

        let items: Vec<_> = stream.collect().await;
        assert!(items.len() >= 3); // hello, world, done

        println!("Items: {:#?}", items);
    }

    #[test]
    fn test_method_enum_schema() {
        let schema = schemars::schema_for!(EchoPluginMethod);
        let json = serde_json::to_string_pretty(&schema).unwrap();
        println!("EchoPluginMethod schema:\n{}", json);

        assert!(json.contains("echo"));
        assert!(json.contains("status"));
        assert!(json.contains("params")); // echo has params
    }

    #[test]
    fn test_event_enum_schema() {
        let schema = schemars::schema_for!(EchoEvent);
        let json = serde_json::to_string_pretty(&schema).unwrap();
        println!("EchoEvent schema:\n{}", json);

        assert!(json.contains("chunk"));
        assert!(json.contains("done"));
    }
}
